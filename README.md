## Прямой поиск в строке

### Задание
Пусть в образце наряду с символами алфавита может встречаться символ * , означающий любую подстроку (в том числе пустую).
Разработать алгоритм для поиска такого образца в исходном тексте.

### Алгоритм
Для решения данной задачи за основу был взят простой и легко переделываемый наивный алгоритм поиска (прямой поиск).
Данный алгоритм ещё называют прямым перебором или BruteForce.<br/>
Он работает в 2 цикла:
1. Первый цикл выполняем проход по все заданной строке и ищет местоположение первой искомой буквы.
2. Второй, начиная с найденной позиции первой буквы, сверяет какие буквы стоят после не и сколько из них подряд совпадают.

В моем алгоритме для программы есть два метода прямого поиска.<br/>
* Один классический, описанный выше. Он возвращает вектор пары индексов, начала и конца вхождения подстроки. 
* Второй же метод улучшен, и он используется для поиска подстроки, если она задана со спец. символом любой подстроки в середине (* в задаче).
Отличается он тем что мы искомую подстроку разделяем на две и ищем их вхождения в тексте. Все вхождения, а именно индексы начал и концов,
сохраняются в векторе и после сравниваются чтобы начала искомой подстроке не оказалось после второй части искомой подстроки. Если такого не оказалось,
то мы объединяем их индексы, то есть в вектор результата заносим начало первой части подстроки и конец второй.<br/>

Вначале мы читаем исходный файл, в котором хранятся данные.
В этом файле входные данные, где:
- 3-количество символов алфавита,
- *- символ любой строки (можно выбрать кроме звездочки любой удобный),
- abc -символы алфавита.

После считывания мы сохраняем алфавит в векторе. И символ подстроки в char.<br/>
Выводим данные для пользователя, инфо об алфавите и знаке.<br/>
Генерируем текст автоматически и записываем его в файл.<br/>
<br/>
Далее мы должны ввести образец для поиска. Для поиска его в тексте отвечает специальная функция. В этой функции мы рассматриваем 4 случая.
1. Когда образец ограничен с конца и начала символом подстроки, то есть *…..*.
Мы удаляем эти знаки и смотрим, есть ли * в середине образца.
Если нет, то используемый обычный прямой поиск и находим индексы.
Иначе используем улучшенный прямой поиск.
2. Когда образец ограничен с начала, то есть  *….
Мы удаляем знак с начала и смотрим, есть ли * в середине образца.
Если нет, то используемый обычный прямой поиск и находим индексы.
Иначе используем улучшенный прямой поиск.
3. Когда образец ограничен с конца, то есть  ….*
Мы удаляем знак с конца и смотрим, есть ли * в середине образца.
Если нет, то используемый обычный прямой поиск и находим индексы.
Иначе используем улучшенный прямой поиск.
4. Случай, когда не ограничен образец.
Мы смотрим, есть ли * в середине образца.
Если нет, то используемый обычный прямой поиск и находим индексы.
Иначе используем улучшенный прямой поиск.

Все результаты у нас хранятся в векторе с индексами начал и концов.<br/>
После чего нам их стоит занести в файл результаты. В файле они выглядят в отличии от случая, который мы рассматривали.
- Если 1, то заносим результаты и возможные индексы начал и конца.
- Если 2, то заносим результаты и возможные индексы начал.
- Если 3, то заносим результаты и возможные индексы концов.
- Если 4, то заносим результаты.

